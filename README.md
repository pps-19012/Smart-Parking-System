# Smart-Parking-System

## How to Run

- Clone the repository
- Install flask: `pip install flask`
- Change url address to the address generated by NodeMCU in get_parking_data() in views.py
- Make sure that your device and NodeMCU are connected to the same network
- Run main.py: `python main.py `
- Website is hosted at http://127.0.0.1:5000

![website](https://github.com/pps-19012/Smart-Parking-System/blob/main/layout.png)

## Features

- Access to the states of parking spots (free, occupied, reserved).
- Access the count of vehicles parked inside.
- Can request reservation to a particular parking spot.
- Reservation last till `x` minutes (`x` can be changed). After, the state is again free.

## Working

1. Global variables:

```python
curr_parking_data = ["0", "0", "0", "0", "0"]  # initial parking data
entry_exit = ["1", "1"]  # intial entry and exit data
timer = [0, 0, 0, 0, 0]  # timer for each parking spot
```

2. To decide the state of the parking spaces, the fronted gets the data from the `/parkingData` GET request. (in `views.py`).

The function first GETS the data from the NODEMCU server.

```python
@views.route('/parkingData', methods=['GET'])
def get_parking_data():
    # Read data from NodeMCU server and Update Google Sheets

    url = "http://192.168.218.188/"  # put the node mcu generate url here.
    response = requests.get(url)
    if response.status_code == 200:
        print("Retrieved data successfully")
    else:
        print("Failed to retrieve data", 500)
```

If the GET request is successful then we update the current state of parking spots. `curr_parking_data` stores the state of parking state.

Here,

- State 0: Occupied
- State 1: Free
- State 2: Reserved

If the currently the state is reserved, then it is changed if a car has now occupied the parking spot. Otherwise, the `curr_parking_data` is update with the latest data from NodeMCU.

```python
if response.status_code == 200:
        data_from_server = response.json()
        if curr_parking_data[0] == '2':
            if str(data_from_server['data0']) == '0':
                curr_parking_data[0] = '0'
        else:
            curr_parking_data[0] = str(data_from_server['data0'])
```

Similarly, we get the entry and exit data:

```python
entry_bit = str(data_from_server['data5'])
exit_bit = str(data_from_server['data6'])
```

To detect the entering (or exiting) of car, we use the falling edge from the NodeMCU signal. `entry_exit` keeps track of the entry and exit signal values. If it is entry was 1 and new data from NodeMCU is 0, then we detect a falling edge and the variable `entry_val` is adjusted. `entry_exit` is updated with the current data.

```python
if entry_exit[0] == "1" and entry_bit == "0":
    entry_val = "1"
else:
    entry_val = "0"
entry_exit[0] = entry_bit
```

Finally we return the response to the GET request to the frontend. It contains the color array which is decided by parking state. `stm32` contains parking data and `entryData` and `exitData` contains the entry/exit information.

```python
colors = ['#dc3545', '#28a745']  # red and green
color = []
for value in parking_data:
    if int(value) != 2:
        color.append(colors[int(value)])
return jsonify({'color': color, 'stm32': parking_data, 'entryData': entry_val, 'exitData': exit_val})
```

3. Updating the frontend (in `home.html`)

   After getting the response from backend, the counter value `inside` is updated by the entry/exit information. Also, the buttons are updated in style and are assigned status, which is, `free` or `occupied` depending upon parking state. The buttons whose status is `reserved` are skipped.

```javascript
function updateButtonColors() {
  fetch("/parkingData")
    .then((response) => response.json())
    .then((data) => {
      // Update the entry and exit count
      entryCount += parseInt(data.entryData);
      exitCount += parseInt(data.exitData);
      console.log(entryCount, exitCount);
      inside = entryCount - exitCount;

      // Update the counter
      document.getElementById("inside-count").innerHTML = `${inside}`;

      // Iterate through the data to update the button colors
      for (let i = 0; i < data.stm32.length; i++) {
        var button = document.getElementById(`btn${i + 1}`);
        if (data.stm32[i] == 2) {
          continue;
        } else {
          button.style.backgroundColor = data.color[i];
          button.style.color = "white";
          if (data.stm32[i] == 1) {
            button.status = "free";
          }
          if (data.stm32[i] == 0) {
            button.status = "occupied";
          }
        }
      }
    })
    .catch((error) => console.error(error));
}
```

4. The feature of reserving a parking space is implemented through a POST request to `/api/reservation`. When a button is clicked, if the parking state is free, then a POST request is sent which contains the id of the button. (in `home.html`)

```javascript
function onButtonClick(button) {
  var button_status = button.status;
  if (button_status == "free") {
    console.log(button.id);
    button.style.backgroundColor = "yellow";
    button.style.color = "black";
    button.status = "reserved";
    fetch("/api/reservation", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ id: button.id }),
    })
      .then((response) => response.json())
      .then((data) => console.log(data))
      .catch((error) => console.error(error));
  }
}
```

5. Updating the parking state and starting timer after the receiving the POST request (in `views.py`)

The function changes the state to '2' (which indicates to the rest of the functions that this parking spot has been reserved), and also sets the `timer[button_index]` to 50.

```python
@views.route('/api/reservation', methods=['POST'])
def reserve_parking():
    button_id = request.json['id']  # extract button_id from JSON data
    # # get the index of the button
    button_index = int(button_id[3]) - 1
    curr_parking_data[button_index] = '2'

    # update timer
    timer[button_index] = 50
    return jsonify({'success': True})
```

6. Timer for reservation (in `get_parking_data()` in `views.py`)

Every time the get_parking_data() function is called, this code block iterates through all the contents of the `timer` array and checks if the value if greater than 0. If it is greater than 0, it means that parking spot was reserved and has not been filled yet. Therefore is `10` subtracted at each GET request. Hence, the parking space will be reserved till `5` GET request. After that, it will be free if not filled.

```python
for i in range(len(timer)):
    if timer[i] > 0:
        # print("Reserved: ", i, " Timer: ", timer[i])
        if curr_parking_data[i] == '2':
            if timer[i] - 10 <= 0:
                curr_parking_data[i] = '1'
                timer[i] = 0
        timer[i] -= 10
```

Note, that the frequency of GET request and the duration of timer can be change by modifying the following:

- Frequency of GET request (in <script></script> in `home.html`)

```javascript
setInterval(updateButtonColors, 2000);
```

- Duration of timer (in `reserve_parking()` in `views.py`)

```python
timer[button_index] = 50
```
